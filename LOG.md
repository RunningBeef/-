## 6.8
* 完成读写.csv文件
* 完成在linux protocol-buffer 配置
## 6.9学习教程

## 6.13学习教程
* https://blog.csdn.net/K346K346/article/details/51754431
* 编译命令  protoc data.proto --cpp_out=./
* 编译命令  g++ main.cpp include/data.pb.cc `pkg-config --cflags --libs protobuf`

## 断线情况
**1、正常网络断开**
* (1) CS 一方调用 Close 如果recv()返回值小于等于0时，客户端的连接已经断开，但是还需要判断errno是否等于EINTR。如果errno=EINTR则说明recv()函数是由于程序接收到中断信号后返回的，socket连接应该还是正常，步应该close掉socket连接。
* (2) CS 一方程序正常退出，如Ctrl + C 事件可以被系统检测到，对应的套接字也将被系统标记为已断开。使用另一个线程执行应用层心跳包检测即可
* (3) 服务器和客户端太长没有发送数据，防火墙之类的软件可能会关闭这个socket 
**2、异常网络断开**
* (1) CS 一方网线被拨出 
* (2) CS 之间路由故障，物理连接断开
* (3) CS 一方断电或当机
* (4) CS 一方无线信号不佳或无线接口被关闭
* CS 一方更改 IP 事件无法被系统检测到，这个时候读数据不会出错，只会一直阻塞着；写数据在缓冲区未满之前也不会返回错误。若无法及时检测到断开事件，对某些应用场景而言可能存在致命的错误。如服务端维护的客户端在线信息错误等。

## 为什么要有断线重连
**服务与服务之间**
* 提高工作效率，如果一个服务先启动，需要连接另一个未启动的服务器，那么如果没有断线重连，连接一次就不连了，导致系统无法正常运行。
* 或者出现网络问题，服务之间的连接突然断了，那么没有断线重连，系统也就无法继续运行了。
* 如果服务器连接或者启动顺序有依赖，那么如果升级一个服务，你需要按顺序升级其它服务很不方便
**服务与客户之间**
* 客户网络状态变化，断线后如果不能自动重连，那么用户只能自动重启，很不方便

**应用层心跳包和TCP心跳比较**
* https://blog.csdn.net/chrisnotfound/article/details/80112736
* 不用TCP的心跳机制：缺点：1.TCP心跳包只能检测连接存活，不能保证连接可用。2.如果TCP一端突然掉线，重传包的优先级高于TCP keepalive心跳包，所以等重传多次失败后，才知道连接出错。优点：内核实现好的，效率高、省流、代码设计简单。
* 应用层心跳检测：优点：1.自定义检测时间、间隔、处理流程，可以在心跳包上附带信息、可以检测连接存在和可以用性。2.协议无关性，即使之后不用TCP用UDP，应用层心跳机制仍然可用。缺点：代码设计复杂，工作量增大。
**心跳包作用**
* 连接保活，如果客户端长期没有和服务端的数据交互，那么连接可能会被防火墙关闭，这样就不能及时接收消息了，心跳机制可以防止这一点
* 检测TCP死链，帮助关闭无效连接，或者断线重连


## 心跳包，检测断线
**逻辑设计**
* 客户端发送心跳包给服务器，服务器回复，保证连接可用
* 如果服务端在规定时间内没有收到心跳包说明客户端不在线，则回收连接关闭对应资源
* 如果客户端在规定时间内没有收到服务端回复，可以采用2^i定时继续发送，如过到达规定次数仍然失败，则报告错误，并调用重连模块
* 客户端当recv()返回值小于等于0时，socket连接断开。但是还需要判断 errno是否等于 EINTR，如果errno == EINTR 则说明recv函数是由于程序接收到信号后返回的，socket连接还是正常的，不应close掉socket连接。
* 若使用了select等系统函数，若远端断开，则select返回1，recv返回0则断开。其他注意事项同法一。
* 操作系统也提供了网络状态发送变化的函数，用来协助判断（本项目部实现

**心跳包设计**
* 数据尽可能的小，减少网络压力
* 提供调试时不使用心跳包机制的选项，因为调试断点时，可能停留时间较就，连接会被心跳机制检测断开，而且心跳包数据可能会干扰
* 提供心跳包是否写入日志选项，心跳包如果没有重要信息可以不写入日志
* 考虑本身服务端和客户端之间就有数据传送，这些包本身就有保活作用，如果再发送心跳包就是浪费流量，所以可以用定时器计时，上次发包时间距离系统时间超过定值才发送心跳包
* 心跳包也可以携带业务数据


**重连模块**
* 定时调用connect重连
* 服务端可以定时每隔3~5秒重连
* 客户端考虑用户所在网络状态可能很恶劣，所以采用2^i时间间隔方法重连，考虑用户体验到达规定时间间隔不再增长。
* 实际上光connect肯定不够，还需要结合具体业务发送账户信息进行身份验证等。